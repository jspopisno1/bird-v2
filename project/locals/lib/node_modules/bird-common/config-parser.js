
// <<[ 动态更新 config 对象 ]{t97zs_zd0tksdx_iom9u7yv}>>
/*
    这个动态更新 config 的逻辑的注意点:

    我们利用js的对象引用保持不变, 动态 extend 新的值到这个对象中进行使用
    这种方法的限制是:

    在任何地方引用到config内的数值, 必须动态的从 config 开始计算获得, 如 config.a.b
    你不能使用 var a = config.a 来进行持久化赋值, 否则, 当config动态更新时, a 已经是老 config 的 a 了

    另: 本方法将不再支持直接将 config object 传给 bird 了, 因为我们需要有一种机制来检测config改变, 需要检测 file 的修改时间戳
 */



var fs = require('fs')
var _ = require('lodash')
var birdUtils = require('bird-common/utils')


module.exports = {
    parse: function(configPath) {
        // 注意, 更新时, 我们只能 extend 进去config, 不能直接替换, 这个是js的引用问题
        var config = {};
        _.extend(config, require(configPath))

        var fsStat = fs.statSync(configPath)

        // 检测 config 的更新
        // hmmmm 不用引 chokidar 了, 直接 setInterval 来欢乐的检测吧
        setInterval(function() {
            var newFsStat = fs.statSync(configPath)

            // console.log('@debug, checking the birdfile', newFsStat.mtime, fsStat.mtime)
            if (newFsStat.mtime > fsStat.mtime) {
                delete require.cache[require.resolve(configPath)];
                try {
                    _.extend(config, require(configPath))

                    // 这个是给 config.debug 用的, 选择是否显示 debug 信息
                    birdUtils.assignConfig(config)

                    birdUtils.log('info', 'Bird config change detected, please refresh your browser to see the new change')
                } catch (ex) {
                    birdUtils.log('error', 'Bird config file is not parsed correctly as a valid js module file')
                    console.log(ex)
                }
                fsStat = newFsStat;

                // console.log('@debug,', config)
            }
        }, 1E3)

        return config;
    }
}